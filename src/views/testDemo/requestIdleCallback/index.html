<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>requestIdleCallback</title>
</head>

<body>
    <div id="root"></div>
    <script src="./requestIdleCallback.js"></script>
    
    <script>
        // const total = 50 * 1000
        // const arr = []


        // function generateArr() {
        //     for (let i = 0; i < total; i++) {
        //         arr.push(function () {
        //             document.body.innerHTML += `<div>${i}</div>`
        //         })
        //     }
        // }
        // generateArr()


        // ----------------------------------------------非常卡顿----------------------------------------------
        // for (let i = 0; i < total; i++) {
        //     arr[i]()
        // }


        // ----------------------------------------------非常丝滑----------------------------------------------
        //requestIdleCallback 浏览器绘制一帧16ms 空闲的时间去执行的函数 浏览器自动执行
        //浏览器一帧做些什么
        //1.处理时间的回调click...事件
        //2.处理计时器的回调
        //3.开始帧
        //4.执行requestAnimationFrame 动画的回调
        //5.计算机页面布局计算 合并到主线程
        //6.绘制
        //7.如果此时还有空闲时间，执行requestIdleCallback


        // https://message163.github.io/react-docs/react/principle/requestidlecallback.html#%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98
        // 【为什么React不用原生requestIdleCallback实现呢?】
        // 【requestIdleCallback替代方案是什么?】

        // function workLoop(deadline) {
        //     // 是否有剩余时间或者是否强制执行
        //     if ((deadline.timeRemaining() > 0 || deadline.didTimeout) && arr.length) {
        //         arr.shift()()
        //     }
        //     requestIdleCallback(workLoop)
        // }
        // requestIdleCallback(workLoop)
    </script>
</body>

</html>